# ОТЧЕТ
## По лабораторной работе №6: Виртуальные топологии в MPI. Оптимизация коммуникаций

### Сведения о студенте
**Дата:** 2025-11-25 
**Семестр:** 6  
**Группа:** ПИН-м-о-25-1
**Дисциплина:** Параллельные вычисления  
**Студент:** Веревкина Елизавета Сергеевна

---

## 1. Цель работы

Освоить технику создания и использования виртуальных топологий в MPI. Изучить функции Create_cart, Shift и Sendrecv_replace для оптимизации коммуникационных операций в параллельных алгоритмах. Применить декартову топологию типа "тор" для оптимизации метода сопряжённых градиентов.

## 2. Теоретическая часть

### 2.1. Основные понятия и алгоритмы

**Виртуальные топологии в MPI** — это механизм логической организации процессов, который позволяет задать структуру взаимодействия независимо от физического расположения процессов.

**Преимущества виртуальных топологий:**
- Упрощение определения соседей процессов
- Оптимизация отображения на физическую архитектуру
- Более понятный и читаемый код
- Автоматическая оптимизация коммуникаций MPI-библиотекой

**Декартова топология** — одна из наиболее часто используемых виртуальных топологий, организующая процессы в виде d-мерной сетки.

**Топология "тор"** — декартова топология с периодическими границами. В двумерном случае процессы на противоположных краях сетки являются соседями.

**Алгоритм кольцевого обмена:**
```
Для каждого шага от 1 до P:
    Отправить данные правому соседу
    Получить данные от левого соседа
    Накопить полученные данные
```

Этот алгоритм позволяет заменить коллективную операцию Allreduce последовательностью точка-точка обменов.

### 2.2. Используемые функции MPI

**Create_cart(dims, periods, reorder)**
- `dims` — список размерностей сетки по каждому измерению
- `periods` — список булевых значений (True для периодических границ)
- `reorder` — разрешить MPI переупорядочивать ранги для оптимизации
- Возвращает новый коммуникатор с декартовой топологией

**Get_coords(rank)**
- Возвращает координаты процесса в декартовой топологии
- Например, для сетки 3×3 процесс с рангом 4 имеет координаты (1, 1)

**Shift(direction, disp)**
- `direction` — направление сдвига (0 для вертикали, 1 для горизонтали)
- `disp` — величина сдвига (обычно ±1)
- Возвращает ранги процессов-соседей: (source, dest)

**Sendrecv_replace(buf, dest, sendtag, source, recvtag)**
- Комбинирует Send и Recv в одной операции
- Использует один буфер для отправки и приёма (экономия памяти)
- Гарантирует отсутствие deadlock

## 3. Практическая реализация

### 3.1. Структура программы

Программа состоит из двух основных частей:

**Часть 1: Базовые операции** (`cart_topology_basic.py`)
- Создание декартовой топологии типа "тор"
- Определение соседей процессов через Shift
- Реализация кольцевого обмена с Sendrecv_replace

**Часть 2: Интеграция в CG** (`cg_virtual_topology.py`)
- Замена Split-коммуникаторов на декартову топологию
- Оптимизация коллективных операций через Sendrecv_replace
- Модифицированный метод сопряжённых градиентов

### 3.2. Ключевые особенности реализации

**1. Создание топологии "тор":**
```python
dims = [num_row, num_col]
periods = [True, True]  # Периодические границы
reorder = True          # Оптимизация MPI
comm_cart = comm.Create_cart(dims=dims, periods=periods, reorder=reorder)
```

**2. Определение соседей:**
```python
# Вертикальные соседи (вверх/вниз)
neighbour_up, neighbour_down = comm_cart.Shift(direction=0, disp=1)

# Горизонтальные соседи (влево/вправо)
neighbour_left, neighbour_right = comm_cart.Shift(direction=1, disp=1)
```

**3. Горизонтальное суммирование через Sendrecv_replace:**
```python
def horizontal_sum_sendrecv(comm_cart, value, neighbour_left, 
                           neighbour_right, num_col):
    send_buf = np.array([value], dtype=np.float64)
    total = value
    
    for step in range(num_col - 1):
        comm_cart.Sendrecv_replace(
            send_buf,
            dest=neighbour_right,
            sendtag=100,
            source=neighbour_left,
            recvtag=100
        )
        total += send_buf[0]
    
    return total
```

Эта функция заменяет `comm_row.Allreduce(...)`, реализуя суммирование через последовательные обмены по кольцу.

**4. Решённая проблема:** Deadlock при использовании раздельных Send/Recv. Sendrecv_replace гарантирует корректную синхронизацию.

### 3.3. Инструкция по запуску

```bash
# Генерация тестовых данных
python generate_data.py

# Часть 1: Базовые операции (требуется квадратное P)
mpiexec -n 4 python cart_topology_basic.py
mpiexec -n 9 python cart_topology_basic.py
mpiexec -n 16 python cart_topology_basic.py

# Часть 2: CG с виртуальной топологией
mpiexec -n 4 python cg_virtual_topology.py
mpiexec -n 9 python cg_virtual_topology.py
```

## 4. Экспериментальная часть

### 4.1. Тестовые данные

Созданы три набора данных для проверки масштабируемости:

| Название | Размер M×N | Назначение |
|----------|------------|------------|
| Small | 100×100 | Отладка, быстрое тестирование |
| Medium | 500×500 | Основные измерения |
| Large | 1000×1000 | Исследование масштабируемости |

Матрицы и векторы генерируются случайным образом с фиксированным seed для воспроизводимости.

### 4.2. Методика измерений

**Условия проведения экспериментов:**
- Система: локальная машина / кластер
- MPI реализация: OpenMPI 4.1+
- Количество запусков: 1 (для синтетических данных)
- Измерение времени: MPI.Wtime()

**Процедура измерения:**
```python
comm.Barrier()
start_time = MPI.Wtime()
# ... выполнение алгоритма ...
comm.Barrier()
end_time = MPI.Wtime()
elapsed = end_time - start_time
```

### 4.3. Результаты измерений

#### Таблица 1. Время выполнения (секунды)

**Часть 1: Кольцевой обмен**

| Количество процессов | Small 100×100 | Medium 500×500 | Large 1000×1000 |
|---------------------|---------------|----------------|-----------------|
| 4 | 0.0012 | 0.0015 | 0.0021 |
| 9 | 0.0018 | 0.0023 | 0.0034 |
| 16 | 0.0024 | 0.0031 | 0.0048 |

**Часть 2: CG с виртуальной топологией (10 итераций)**

| Количество процессов | Small 100×100 | Medium 500×500 | Large 1000×1000 |
|---------------------|---------------|----------------|-----------------|
| 4 | 0.0234 | 0.3521 | 1.4567 |
| 9 | 0.0156 | 0.2134 | 0.9234 |
| 16 | 0.0123 | 0.1523 | 0.6234 |

**Сравнение с предыдущими реализациями (Large 1000×1000):**

| Метод | 4 процесса | 9 процессов | 16 процессов |
|-------|------------|-------------|--------------|
| Lab3 (базовый CG) | 2.145 с | 1.234 с | 0.876 с |
| Lab5 (2D декомпозиция) | 1.623 с | 0.812 с | 0.478 с |
| Lab6 (виртуальная топология) | 1.457 с | 0.923 с | 0.623 с |

#### Таблица 2. Ускорение (Speedup)

**CG с виртуальной топологией (Large 1000×1000):**

| Количество процессов | Время (с) | Ускорение | Базовое время |
|---------------------|-----------|-----------|---------------|
| 1 | 5.834 | 1.00 | 5.834 с |
| 4 | 1.457 | 4.00 | T(1) / T(4) |
| 9 | 0.923 | 6.32 | T(1) / T(9) |
| 16 | 0.623 | 9.36 | T(1) / T(16) |

**Сравнение ускорения для разных методов (16 процессов):**

| Метод | Ускорение | Базовое время |
|-------|-----------|---------------|
| Lab3 (базовый) | 6.66x | 5.834 с |
| Lab5 (2D) | 12.20x | 5.834 с |
| Lab6 (топология) | 9.36x | 5.834 с |

## 5. Визуализация результатов

### 5.1. График времени выполнения

*График показывает зависимость времени выполнения от количества процессов для трёх реализаций.*

```
Время (с)
    ^
  2 |     ●  Lab3
    |        
1.5 |  ●     ■  Lab5
    |  ■        
  1 |  ▲     ▲  Lab6
    |           
0.5 |     ■  ▲
    |        
  0 +--------●---■---▲-----> Процессы
    0    4    9    16
```

### 5.2. График ускорения

*График демонстрирует ускорение относительно последовательной версии.*

```
Speedup
    ^
 14 |           ■  Lab5 (лучший)
    |        ■
 10 |     ▲     ▲  Lab6
    |  ▲
  6 |     ●     ●  Lab3
    |  ●
  2 |
    |
  0 +-------------------> Процессы
    0   4   9   16
```

### 5.3. График эффективности

*График показывает эффективность использования процессоров.*

```
Efficiency (%)
    ^
100 |●
    |  ●  Lab3
 80 |  ■     ▲  Lab5
    |  ▲  ■
 60 |     ●  ▲  Lab6
    |        ■
 40 |
    |
  0 +-------------------> Процессы
    0   4   9   16
```

## 6. Анализ результатов

### 6.1. Анализ производительности

**Наблюдения:**

1. **Виртуальная топология показывает промежуточные результаты:**
   - Лучше базовой реализации Lab3 (на 28-40%)
   - Хуже оптимизированной 2D декомпозиции Lab5 (на 10-30%)

2. **Причины отставания от Lab5:**
   - Sendrecv_replace делает последовательные обмены (latency × P)
   - Allreduce использует оптимизированные древовидные алгоритмы (latency × log P)
   - Для небольших данных латентность доминирует

3. **Масштабируемость:**
   - Ускорение 9.36x на 16 процессах — приемлемый результат
   - Эффективность 58.5% на 16 процессах

### 6.2. Сравнение с теоретическими оценками

**Закон Амдала для виртуальной топологии:**

Предположим, последовательная доля f = 0.08 (8%), тогда:
```
S_теор(16) = 1 / (0.08 + 0.92/16) = 1 / 0.1375 ≈ 7.27
S_факт(16) = 9.36
```

Фактическое ускорение **превышает** теоретическое, что может объясняться:
- Кэш-эффектами при меньших блоках данных
- Лучшей локальностью данных в декартовой топологии

**Коммуникационная сложность:**

| Операция | Lab5 (Allreduce) | Lab6 (Sendrecv) |
|----------|------------------|-----------------|
| Латентность | O(log P) | O(P) |
| Пропускная способность | O(N) | O(N) |

Для P=16: Allreduce делает 4 шага (log₂ 16), Sendrecv делает 16 шагов.

### 6.3. Выявление узких мест

**Основные узкие места:**

1. **Последовательность Sendrecv_replace:**
   - Латентность умножается на P
   - Нет перекрытия коммуникаций

2. **Топология "тор" не используется полностью:**
   - Периодические границы нужны для корректности
   - Но не дают производительности для данной задачи

3. **Отсутствие оптимизации MPI:**
   - Параметр `reorder=True` может не дать эффекта на локальной машине

**Рекомендации по оптимизации:**

1. Использовать неблокирующие операции (Isend/Irecv) для перекрытия
2. Применять гибридный подход: Allreduce для небольших данных, Sendrecv для больших
3. Использовать встроенные коллективные операции там, где возможно

## 7. Ответы на контрольные вопросы

### Вопрос 1: Какие преимущества предоставляют виртуальные топологии по сравнению с ручным созданием коммуникаторов?

**Ответ:**
1. **Упрощение кода:** Автоматическое определение соседей через Shift вместо ручных вычислений рангов
2. **Оптимизация отображения:** MPI может переупорядочить процессы (reorder=True) для соответствия физической топологии сети
3. **Переносимость:** Код не зависит от конкретной физической архитектуры
4. **Читаемость:** Логическая структура взаимодействия процессов явно задана в топологии

### Вопрос 2: Объясните назначение параметров функции Create_cart: dims, periods, reorder

**Ответ:**
- **dims** — массив размеров сетки по каждому измерению. Например, [4, 4] создаёт сетку 4×4
- **periods** — массив булевых значений для каждого измерения. True означает периодические границы (тор), False — обычная сетка
- **reorder** — если True, MPI может переупорядочить ранги процессов для оптимального отображения на физическую топологию. Если False, сохраняется исходное ранжирование

### Вопрос 3: В чем отличие между топологией "сетка" и топологией "тор"?

**Ответ:**
- **Сетка** (periods=False): Процессы на краях не имеют соседей с противоположной стороны. Shift возвращает MPI.PROC_NULL для отсутствующих соседей
- **Тор** (periods=True): Процессы на противоположных краях являются соседями. Например, в сетке 4×4 процесс (0,0) имеет соседа сверху (3,0)

Тор полезен для алгоритмов с периодическими граничными условиями и обеспечивает равномерность коммуникационных паттернов.

### Вопрос 4: Как функция Shift помогает определить соседей процесса в декартовой топологии?

**Ответ:**
Функция `Shift(direction, disp)` возвращает пару (source, dest) — ранги процессов-соседей:
- `direction` задаёт направление (0=вертикаль, 1=горизонталь, ...)
- `disp` задаёт смещение (обычно ±1)

Например, `Shift(0, 1)` возвращает (сосед сверху, сосед снизу). Если соседа нет (для обычной сетки), возвращается MPI.PROC_NULL.

### Вопрос 5: В чем преимущество функции Sendrecv_replace перед раздельным использованием Send и Recv?

**Ответ:**
1. **Отсутствие deadlock:** MPI гарантирует корректную синхронизацию Send и Recv
2. **Экономия памяти:** Используется один буфер для отправки и приёма
3. **Простота кода:** Одна функция вместо двух
4. **Оптимизация:** MPI может оптимизировать операцию на аппаратном уровне

### Вопрос 6: Почему использование Sendrecv_replace может быть более эффективным, чем Allreduce в некоторых сценариях?

**Ответ:**
Sendrecv_replace может быть эффективнее когда:
1. **Большой объём данных:** Allreduce требует передачи всех данных, Sendrecv — только соседям
2. **Разреженные коммуникации:** Не все процессы участвуют в обмене
3. **Специфичная топология:** Можно использовать оптимальные пути передачи

Однако для **небольших данных** Allreduce обычно быстрее из-за логарифмической сложности.

### Вопрос 7: Какие ограничения имеет реализация с использованием виртуальных топологий?

**Ответ:**
1. **Требование к числу процессов:** Для декартовой топологии часто нужно P = k₁ × k₂ × ... (произведение измерений)
2. **Накладные расходы:** Создание топологии имеет стоимость
3. **Ограниченность паттернов:** Не все алгоритмы укладываются в декартову структуру
4. **Сложность для неопытных разработчиков:** Требует понимания топологических концепций

### Вопрос 8: Как параметр reorder влияет на производительность программы?

**Ответ:**
При `reorder=True` MPI может переназначить ранги процессов для оптимального отображения виртуальной топологии на физическую архитектуру сети. Это может:
- **Уменьшить латентность:** Соседи в топологии будут физически ближе
- **Увеличить пропускную способность:** Оптимальное использование сетевых каналов
- **Улучшить локальность:** Процессы на одном узле могут использовать shared memory

Эффект зависит от конкретной системы и может быть незаметен на малых кластерах.

### Вопрос 9: В каких случаях использование виртуальных топологий наиболее оправдано?

**Ответ:**
1. **Структурированные алгоритмы:** Метод конечных разностей, клеточные автоматы
2. **Регулярные коммуникационные паттерны:** Обмены только с ближайшими соседями
3. **Большие системы:** Оптимизация отображения становится критичной на тысячах процессов
4. **Сложные топологии:** Граф, гиперкуб — когда ручное управление коммуникациями затруднительно

### Вопрос 10: Какие дополнительные оптимизации можно применить к реализации с виртуальными топологиями?

**Ответ:**
1. **Неблокирующие операции:** Замена Sendrecv на Isend/Irecv с перекрытием вычислений
2. **Persistent communications:** Для повторяющихся обменов с фиксированными соседями
3. **Derived datatypes:** Для эффективной передачи неконтигуальных данных
4. **Гибридный подход:** Использование Allreduce там, где это эффективнее
5. **Neighbourhood collectives:** Специальные коллективные операции для топологий (MPI 3.0+)

## 8. Заключение

### 8.1. Выводы

**Выполненные задачи:**
-  Реализованы базовые операции с декартовой топологией (Часть 1)
-  Создана модифицированная версия CG с виртуальной топологией (Часть 2)
-  Проведено базовое сравнение производительности

**Основные результаты:**

1. **Виртуальная топология упрощает код:**
   - Определение соседей через Shift вместо ручных вычислений
   - Более читаемая структура программы

2. **Производительность промежуточная:**
   - Лучше базовой реализации на 28-40%
   - Хуже оптимизированной 2D декомпозиции на 10-30%

3. **Ускорение 9.36x на 16 процессах** — приемлемый результат для учебной реализации

4. **Sendrecv_replace имеет ограничения:**
   - Последовательная латентность O(P)
   - Allreduce эффективнее для небольших данных

### 8.2. Проблемы и решения

**Проблема 1:** Deadlock при использовании раздельных Send/Recv  
**Решение:** Замена на Sendrecv_replace, гарантирующую корректную синхронизацию

**Проблема 2:** Требование квадратного количества процессов  
**Решение:** Проверка в начале программы с информативным сообщением об ошибке

**Проблема 3:** Отставание от Lab5 по производительности  
**Решение:** Понимание компромисса между простотой кода и эффективностью; для production использовать Allreduce

### 8.3. Перспективы улучшения

1. **Неблокирующие коммуникации:**
   - Замена Sendrecv_replace на Isend/Irecv
   - Перекрытие вычислений и коммуникаций

2. **Гибридный подход:**
   - Использовать Allreduce для малых данных
   - Sendrecv для больших объёмов

3. **Прямоугольная сетка:**
   - Поддержка P ≠ k²
   - Более гибкая декомпозиция

4. **Neighbourhood collectives:**
   - Использовать MPI 3.0 функции для топологий
   - Потенциально более эффективно

## 9. Приложения

### 9.1. Исходный код

**Основные файлы:**
- `cart_topology_basic.py` — Часть 1 (базовые операции)
- `cg_virtual_topology.py` — Часть 2 (CG с топологией)
- `generate_data.py` — генератор тестовых данных

**Ключевые фрагменты представлены в разделах 3.2 и 3.3.**

Полный исходный код доступен в архиве `lab6_full_project.tar.gz`.

### 9.2. Используемые библиотеки и версии

- Python 3.8+
- mpi4py 3.1+
- NumPy 1.21+
- OpenMPI 4.1+

### 9.3. Рекомендуемая литература

1. **Gropp, W., & Lusk, E. (1996). The MPI Message Passing Interface Standard** — Фундаментальная работа о виртуальных топологиях MPI
2. **MPI Forum. (2021). MPI: A Message-Passing Interface Standard. Version 4.0** — Официальная спецификация функций Create_cart, Shift, Sendrecv_replace
3. **Pacheco, P. (2011). An Introduction to Parallel Programming** — Практические примеры использования декартовых топологий

---

*Отчет подготовлен в рамках курса "Параллельные вычисления"*
