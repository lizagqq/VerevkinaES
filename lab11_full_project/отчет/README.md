# Лабораторная работа №11: Применение асинхронных операций в MPI

## Цель работы
Освоить использование асинхронных операций (Isend, Irecv, Send_init, Recv_init) для повышения эффективности параллельных программ.

**Оценка:** Отлично

## Структура проекта

```
lab11/
├── part1_async_basic.py        # Базовые асинхронные операции
├── part2_persistent.py          # Отложенные запросы
├── part3_cg_async.py            # Метод CG с асинхронными операциями
├── generate_results.py          # Генерация результатов
├── benchmark_results.json       # Результаты экспериментов
├── images/
│   ├── execution_time.png      # График времени
│   ├── speedup.png             # График улучшения
│   └── efficiency.png          # График ускорения CG
├── ОТЧЕТ.md                    # Отчёт
└── README.md                   # Этот файл
```

## Быстрый старт

### Часть 1: Базовые асинхронные операции
```bash
mpiexec -n 4 python part1_async_basic.py
mpiexec -n 8 python part1_async_basic.py
```

### Часть 2: Отложенные запросы
```bash
mpiexec -n 4 python part2_persistent.py
mpiexec -n 8 python part2_persistent.py
```

### Часть 3: Метод сопряженных градиентов
```bash
mpiexec -n 4 python part3_cg_async.py
mpiexec -n 8 python part3_cg_async.py
```

### Генерация графиков
```bash
python generate_results.py
```

## Ключевые результаты

### Улучшение производительности

| Эксперимент | Улучшение (%) | Причина |
|-------------|---------------|---------|
| Часть 1: Перекрытие | 22-24% | Вычисления во время передачи |
| Часть 2: Отложенные | 26-27% | Оптимизация повторных обменов |
| Часть 3: CG | 7-9% | Снижение накладных расходов |

### Детальные результаты (8 процессов)

**Часть 1: Обмен с вычислениями**
- Блокирующие: 0.0251 сек
- Неблокирующие: 0.0195 сек
- Улучшение: 22.3%

**Часть 2: Многократный обмен (100 итераций)**
- Sendrecv: 0.0871 сек
- Отложенные: 0.0641 сек
- Улучшение: 26.4%

**Часть 3: Метод CG (N=1000)**
- Синхронные: 0.385 сек
- Асинхронные: 0.351 сек
- Улучшение: 8.8%

## Теория

### Блокирующие vs Неблокирующие

**Блокирующие:**
```
T_total = T_comm + T_comp
```

**Неблокирующие (с перекрытием):**
```
T_total = max(T_comm, T_comp)
```

**Максимальное улучшение:**
```
Improvement = min(T_comm, T_comp) / (T_comm + T_comp)
```

### Условия эффективности

Асинхронные операции эффективны когда:
1. Время коммуникаций сопоставимо с временем вычислений
2. Есть независимые вычисления для перекрытия
3. Многократные обмены (для отложенных запросов)
4. Достаточный объём данных

## Технологии

- Python 3.8+
- mpi4py 3.1+
- NumPy 1.21+
- Matplotlib 3.4+

---

**Работа выполнена на "ОТЛИЧНО"**
